/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Server
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 8.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GetAll401Response,
  GetKeysForUser200Response,
  GetRepositoriesRecentlyAccessed200Response,
  RestGpgKey,
  RestRepositorySelector,
  RestSecretScanningAllowlistRule,
  RestSecretScanningAllowlistRuleSetRequest,
  RestSecretScanningRule,
  RestSecretScanningRuleSetRequest,
  Search2200Response,
  Search3200Response,
} from '../models';

interface AddKeyRequest {
    user?: string;
    restGpgKey?: RestGpgKey;
}

interface BulkAddExemptRepositoriesRequest {
    restRepositorySelector?: Set<RestRepositorySelector>;
}

interface BulkAddExemptRepositories1Request {
    restRepositorySelector?: Set<RestRepositorySelector>;
}

interface CreateAllowlistRuleRequest {
    projectKey: string;
    restSecretScanningAllowlistRuleSetRequest: RestSecretScanningAllowlistRuleSetRequest;
}

interface CreateAllowlistRule1Request {
    projectKey: string;
    repositorySlug: string;
    restSecretScanningAllowlistRuleSetRequest: RestSecretScanningAllowlistRuleSetRequest;
}

interface CreateRuleRequest {
    projectKey: string;
    restSecretScanningRuleSetRequest: RestSecretScanningRuleSetRequest;
}

interface CreateRule1Request {
    projectKey: string;
    repositorySlug: string;
    restSecretScanningRuleSetRequest: RestSecretScanningRuleSetRequest;
}

interface CreateRule2Request {
    restSecretScanningRuleSetRequest: RestSecretScanningRuleSetRequest;
}

interface DeleteAllowlistRuleRequest {
    projectKey: string;
    id: string;
}

interface DeleteAllowlistRule1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface DeleteForUserRequest {
    user?: string;
}

interface DeleteKeyRequest {
    fingerprintOrId: string;
}

interface DeleteRuleRequest {
    projectKey: string;
    id: string;
}

interface DeleteRule1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface DeleteRule2Request {
    id: string;
}

interface EditAllowlistRuleRequest {
    projectKey: string;
    id: string;
    restSecretScanningAllowlistRuleSetRequest: RestSecretScanningAllowlistRuleSetRequest;
}

interface EditAllowlistRule1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
    restSecretScanningAllowlistRuleSetRequest: RestSecretScanningAllowlistRuleSetRequest;
}

interface EditRuleRequest {
    projectKey: string;
    id: string;
    restSecretScanningRuleSetRequest: RestSecretScanningRuleSetRequest;
}

interface EditRule1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
    restSecretScanningRuleSetRequest: RestSecretScanningRuleSetRequest;
}

interface EditRule2Request {
    id: string;
    restSecretScanningRuleSetRequest: RestSecretScanningRuleSetRequest;
}

interface FindExemptReposByProjectRequest {
    order?: FindExemptReposByProjectOrderEnum;
    start?: number;
    limit?: number;
}

interface FindExemptReposByScopeRequest {
    order?: FindExemptReposByScopeOrderEnum;
    start?: number;
    limit?: number;
}

interface GetAllowlistRuleRequest {
    projectKey: string;
    id: string;
}

interface GetAllowlistRule1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface GetKeysForUserRequest {
    user?: string;
    start?: number;
    limit?: number;
}

interface GetRuleRequest {
    projectKey: string;
    id: string;
}

interface GetRule1Request {
    projectKey: string;
    id: string;
    repositorySlug: string;
}

interface GetRule2Request {
    id: string;
}

interface Search1Request {
    projectKey: string;
    filter?: string;
    order?: Search1OrderEnum;
    start?: number;
    limit?: number;
}

interface Search2Request {
    projectKey: string;
    repositorySlug: string;
    filter?: string;
    order?: Search2OrderEnum;
    start?: number;
    limit?: number;
}

interface Search3Request {
    projectKey: string;
    repositorySlug: string;
    filter?: string;
    order?: Search3OrderEnum;
    start?: number;
    limit?: number;
}

interface Search4Request {
    filter?: string;
    order?: Search4OrderEnum;
    start?: number;
    limit?: number;
}

interface SearchAllowlistRuleRequest {
    projectKey: string;
    filter?: string;
    order?: SearchAllowlistRuleOrderEnum;
    start?: number;
    limit?: number;
}

/**
 * 
 */
export class SecurityApi extends runtime.BaseAPI {

    /**
     * Exempt a repository from being scanned for secrets   <strong>Deprecated since 8.6</strong>. Exemptions are now managed by scope.  Use POST /rest/api/1.0/secret-scanning/exempt for global scope  Use POST /rest/api/1.0/projects/{projectKey}/secret-scanning/exempt for the project scope
     * Exempt a repo from secret scanning
     */
    async addExemptRepoRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/exempt`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Exempt a repository from being scanned for secrets   <strong>Deprecated since 8.6</strong>. Exemptions are now managed by scope.  Use POST /rest/api/1.0/secret-scanning/exempt for global scope  Use POST /rest/api/1.0/projects/{projectKey}/secret-scanning/exempt for the project scope
     * Exempt a repo from secret scanning
     */
    async addExemptRepo(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addExemptRepoRaw(initOverrides);
    }

    /**
     * Add a GPG key to the authenticated user\'s account. Optionally, users with ADMIN and higher permissions may choose to specify the <code>user</code> parameter to add a GPG key for another user.  Only authenticated users may call this endpoint.
     * Create a GPG key
     */
    async addKeyRaw(requestParameters: AddKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestGpgKey>> {
        const queryParameters: any = {};

        if (requestParameters.user !== undefined) {
            queryParameters['user'] = requestParameters.user;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/gpg/latest/keys`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restGpgKey,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add a GPG key to the authenticated user\'s account. Optionally, users with ADMIN and higher permissions may choose to specify the <code>user</code> parameter to add a GPG key for another user.  Only authenticated users may call this endpoint.
     * Create a GPG key
     */
    async addKey(requestParameters: AddKeyRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestGpgKey> {
        const response = await this.addKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bulk exempt a  list of repositories from being scanned for secrets. User must be have global **ADMIN** permissions.
     * Bulk exempt repos from secret scanning
     */
    async bulkAddExemptRepositoriesRaw(requestParameters: BulkAddExemptRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/secret-scanning/exempt`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restRepositorySelector,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Bulk exempt a  list of repositories from being scanned for secrets. User must be have global **ADMIN** permissions.
     * Bulk exempt repos from secret scanning
     */
    async bulkAddExemptRepositories(requestParameters: BulkAddExemptRepositoriesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.bulkAddExemptRepositoriesRaw(requestParameters, initOverrides);
    }

    /**
     * Bulk exempt a  list of repositories from being scanned for secrets. User must be have **PROJECT ADMIN** permissions.
     * Bulk exempt repos from secret scanning
     */
    async bulkAddExemptRepositories1Raw(requestParameters: BulkAddExemptRepositories1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/exempt`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restRepositorySelector,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Bulk exempt a  list of repositories from being scanned for secrets. User must be have **PROJECT ADMIN** permissions.
     * Bulk exempt repos from secret scanning
     */
    async bulkAddExemptRepositories1(requestParameters: BulkAddExemptRepositories1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.bulkAddExemptRepositories1Raw(requestParameters, initOverrides);
    }

    /**
     * Create a new project level secret scanning allowlist rule. Project allowlist rules are used when scanning all non exempt repositories in the provided project.  Project **Admin** is required
     * Create project secret scanning allowlist rule
     */
    async createAllowlistRuleRaw(requestParameters: CreateAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningAllowlistRule>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling createAllowlistRule.');
        }

        if (requestParameters.restSecretScanningAllowlistRuleSetRequest === null || requestParameters.restSecretScanningAllowlistRuleSetRequest === undefined) {
            throw new runtime.RequiredError('restSecretScanningAllowlistRuleSetRequest','Required parameter requestParameters.restSecretScanningAllowlistRuleSetRequest was null or undefined when calling createAllowlistRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/allowlist`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restSecretScanningAllowlistRuleSetRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new project level secret scanning allowlist rule. Project allowlist rules are used when scanning all non exempt repositories in the provided project.  Project **Admin** is required
     * Create project secret scanning allowlist rule
     */
    async createAllowlistRule(requestParameters: CreateAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningAllowlistRule> {
        const response = await this.createAllowlistRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new repository secret scanning allowlist rule. Repository allowlist rules are used when scanning the given repository.  Repository **Admin** is required
     * Create repository secret scanning allowlist rule
     */
    async createAllowlistRule1Raw(requestParameters: CreateAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningAllowlistRule>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling createAllowlistRule1.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling createAllowlistRule1.');
        }

        if (requestParameters.restSecretScanningAllowlistRuleSetRequest === null || requestParameters.restSecretScanningAllowlistRuleSetRequest === undefined) {
            throw new runtime.RequiredError('restSecretScanningAllowlistRuleSetRequest','Required parameter requestParameters.restSecretScanningAllowlistRuleSetRequest was null or undefined when calling createAllowlistRule1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/allowlist`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restSecretScanningAllowlistRuleSetRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new repository secret scanning allowlist rule. Repository allowlist rules are used when scanning the given repository.  Repository **Admin** is required
     * Create repository secret scanning allowlist rule
     */
    async createAllowlistRule1(requestParameters: CreateAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningAllowlistRule> {
        const response = await this.createAllowlistRule1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new project level secret scanning rule. Project rules are used when scanning all non exempt repositories in the provided project.  Project **Admin** is required
     * Create project secret scanning rule
     */
    async createRuleRaw(requestParameters: CreateRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling createRule.');
        }

        if (requestParameters.restSecretScanningRuleSetRequest === null || requestParameters.restSecretScanningRuleSetRequest === undefined) {
            throw new runtime.RequiredError('restSecretScanningRuleSetRequest','Required parameter requestParameters.restSecretScanningRuleSetRequest was null or undefined when calling createRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/rules`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restSecretScanningRuleSetRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new project level secret scanning rule. Project rules are used when scanning all non exempt repositories in the provided project.  Project **Admin** is required
     * Create project secret scanning rule
     */
    async createRule(requestParameters: CreateRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.createRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new repository secret scanning rule. Repository rules are used when scanning the given repository.  Repository **Admin** is required
     * Create repository secret scanning rule
     */
    async createRule1Raw(requestParameters: CreateRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling createRule1.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling createRule1.');
        }

        if (requestParameters.restSecretScanningRuleSetRequest === null || requestParameters.restSecretScanningRuleSetRequest === undefined) {
            throw new runtime.RequiredError('restSecretScanningRuleSetRequest','Required parameter requestParameters.restSecretScanningRuleSetRequest was null or undefined when calling createRule1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/rules`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restSecretScanningRuleSetRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new repository secret scanning rule. Repository rules are used when scanning the given repository.  Repository **Admin** is required
     * Create repository secret scanning rule
     */
    async createRule1(requestParameters: CreateRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.createRule1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new global secret scanning rule. Global rules are used when scanning all non exempt repositories.
     * Create global secret scanning rule
     */
    async createRule2Raw(requestParameters: CreateRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters.restSecretScanningRuleSetRequest === null || requestParameters.restSecretScanningRuleSetRequest === undefined) {
            throw new runtime.RequiredError('restSecretScanningRuleSetRequest','Required parameter requestParameters.restSecretScanningRuleSetRequest was null or undefined when calling createRule2.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/secret-scanning/rules`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restSecretScanningRuleSetRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new global secret scanning rule. Global rules are used when scanning all non exempt repositories.
     * Create global secret scanning rule
     */
    async createRule2(requestParameters: CreateRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.createRule2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a project secret scanning allowlist rule with the provided ID.  Project **Admin** is required
     * Delete a project secret scanning allowlist rule
     */
    async deleteAllowlistRuleRaw(requestParameters: DeleteAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling deleteAllowlistRule.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteAllowlistRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/allowlist/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a project secret scanning allowlist rule with the provided ID.  Project **Admin** is required
     * Delete a project secret scanning allowlist rule
     */
    async deleteAllowlistRule(requestParameters: DeleteAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAllowlistRuleRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a repository secret scanning allowlist rule with the provided ID.  Repository **Admin** is required
     * Delete a repository secret scanning allowlist rule
     */
    async deleteAllowlistRule1Raw(requestParameters: DeleteAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling deleteAllowlistRule1.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteAllowlistRule1.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling deleteAllowlistRule1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/allowlist/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a repository secret scanning allowlist rule with the provided ID.  Repository **Admin** is required
     * Delete a repository secret scanning allowlist rule
     */
    async deleteAllowlistRule1(requestParameters: DeleteAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAllowlistRule1Raw(requestParameters, initOverrides);
    }

    /**
     * Remove a repository from being exempt from secret scanning
     * Delete an exempt repository
     */
    async deleteExemptRepoRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/exempt`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove a repository from being exempt from secret scanning
     * Delete an exempt repository
     */
    async deleteExemptRepo(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteExemptRepoRaw(initOverrides);
    }

    /**
     * Delete all GPG keys for a supplied user.
     * Delete all GPG keys for user
     */
    async deleteForUserRaw(requestParameters: DeleteForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.user !== undefined) {
            queryParameters['user'] = requestParameters.user;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/gpg/latest/keys`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete all GPG keys for a supplied user.
     * Delete all GPG keys for user
     */
    async deleteForUser(requestParameters: DeleteForUserRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteForUserRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the GPG key with the specified ID or Key Fingerprint.
     * Delete a GPG key
     */
    async deleteKeyRaw(requestParameters: DeleteKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.fingerprintOrId === null || requestParameters.fingerprintOrId === undefined) {
            throw new runtime.RequiredError('fingerprintOrId','Required parameter requestParameters.fingerprintOrId was null or undefined when calling deleteKey.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/gpg/latest/keys/{fingerprintOrId}`.replace(`{${"fingerprintOrId"}}`, encodeURIComponent(String(requestParameters.fingerprintOrId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the GPG key with the specified ID or Key Fingerprint.
     * Delete a GPG key
     */
    async deleteKey(requestParameters: DeleteKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteKeyRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a project secret scanning rule with the provided ID.  Project **Admin** is required
     * Delete a project secret scanning rule
     */
    async deleteRuleRaw(requestParameters: DeleteRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling deleteRule.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/rules/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a project secret scanning rule with the provided ID.  Project **Admin** is required
     * Delete a project secret scanning rule
     */
    async deleteRule(requestParameters: DeleteRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRuleRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a repository secret scanning rule with the provided ID.  Repository **Admin** is required
     * Delete a repository secret scanning rule
     */
    async deleteRule1Raw(requestParameters: DeleteRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling deleteRule1.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteRule1.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling deleteRule1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/rules/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a repository secret scanning rule with the provided ID.  Repository **Admin** is required
     * Delete a repository secret scanning rule
     */
    async deleteRule1(requestParameters: DeleteRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRule1Raw(requestParameters, initOverrides);
    }

    /**
     * Delete a global secret scanning rule with the provided ID
     * Delete a global secret scanning rule
     */
    async deleteRule2Raw(requestParameters: DeleteRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteRule2.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/secret-scanning/rules/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a global secret scanning rule with the provided ID
     * Delete a global secret scanning rule
     */
    async deleteRule2(requestParameters: DeleteRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRule2Raw(requestParameters, initOverrides);
    }

    /**
     * Edit a project secret scanning allowlist rule.  Project **Admin** is required
     * Edit an existing project secret scanning allowlist rule
     */
    async editAllowlistRuleRaw(requestParameters: EditAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningAllowlistRule>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling editAllowlistRule.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling editAllowlistRule.');
        }

        if (requestParameters.restSecretScanningAllowlistRuleSetRequest === null || requestParameters.restSecretScanningAllowlistRuleSetRequest === undefined) {
            throw new runtime.RequiredError('restSecretScanningAllowlistRuleSetRequest','Required parameter requestParameters.restSecretScanningAllowlistRuleSetRequest was null or undefined when calling editAllowlistRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/allowlist/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restSecretScanningAllowlistRuleSetRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Edit a project secret scanning allowlist rule.  Project **Admin** is required
     * Edit an existing project secret scanning allowlist rule
     */
    async editAllowlistRule(requestParameters: EditAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningAllowlistRule> {
        const response = await this.editAllowlistRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit a repository secret scanning allowlist rule.  Repository **Admin** is required
     * Edit an existing repository secret scanning allowlist rule
     */
    async editAllowlistRule1Raw(requestParameters: EditAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningAllowlistRule>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling editAllowlistRule1.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling editAllowlistRule1.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling editAllowlistRule1.');
        }

        if (requestParameters.restSecretScanningAllowlistRuleSetRequest === null || requestParameters.restSecretScanningAllowlistRuleSetRequest === undefined) {
            throw new runtime.RequiredError('restSecretScanningAllowlistRuleSetRequest','Required parameter requestParameters.restSecretScanningAllowlistRuleSetRequest was null or undefined when calling editAllowlistRule1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/allowlist/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restSecretScanningAllowlistRuleSetRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Edit a repository secret scanning allowlist rule.  Repository **Admin** is required
     * Edit an existing repository secret scanning allowlist rule
     */
    async editAllowlistRule1(requestParameters: EditAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningAllowlistRule> {
        const response = await this.editAllowlistRule1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit a project secret scanning rule.  Project **Admin** is required
     * Edit an existing project secret scanning rule
     */
    async editRuleRaw(requestParameters: EditRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling editRule.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling editRule.');
        }

        if (requestParameters.restSecretScanningRuleSetRequest === null || requestParameters.restSecretScanningRuleSetRequest === undefined) {
            throw new runtime.RequiredError('restSecretScanningRuleSetRequest','Required parameter requestParameters.restSecretScanningRuleSetRequest was null or undefined when calling editRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/rules/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restSecretScanningRuleSetRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Edit a project secret scanning rule.  Project **Admin** is required
     * Edit an existing project secret scanning rule
     */
    async editRule(requestParameters: EditRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.editRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit a repository secret scanning rule.  Repository **Admin** is required
     * Edit an existing repository secret scanning rule
     */
    async editRule1Raw(requestParameters: EditRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling editRule1.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling editRule1.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling editRule1.');
        }

        if (requestParameters.restSecretScanningRuleSetRequest === null || requestParameters.restSecretScanningRuleSetRequest === undefined) {
            throw new runtime.RequiredError('restSecretScanningRuleSetRequest','Required parameter requestParameters.restSecretScanningRuleSetRequest was null or undefined when calling editRule1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/rules/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restSecretScanningRuleSetRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Edit a repository secret scanning rule.  Repository **Admin** is required
     * Edit an existing repository secret scanning rule
     */
    async editRule1(requestParameters: EditRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.editRule1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit an existing global secret scanning rule
     * Edit a global secret scanning rule.
     */
    async editRule2Raw(requestParameters: EditRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling editRule2.');
        }

        if (requestParameters.restSecretScanningRuleSetRequest === null || requestParameters.restSecretScanningRuleSetRequest === undefined) {
            throw new runtime.RequiredError('restSecretScanningRuleSetRequest','Required parameter requestParameters.restSecretScanningRuleSetRequest was null or undefined when calling editRule2.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/secret-scanning/rules/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restSecretScanningRuleSetRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Edit an existing global secret scanning rule
     * Edit a global secret scanning rule.
     */
    async editRule2(requestParameters: EditRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.editRule2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find repositories exempt from secret scanning in a project
     * Find repos exempt from secret scanning for a project
     */
    async findExemptReposByProjectRaw(requestParameters: FindExemptReposByProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoriesRecentlyAccessed200Response>> {
        const queryParameters: any = {};

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/exempt`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find repositories exempt from secret scanning in a project
     * Find repos exempt from secret scanning for a project
     */
    async findExemptReposByProject(requestParameters: FindExemptReposByProjectRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoriesRecentlyAccessed200Response> {
        const response = await this.findExemptReposByProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find all repositories exempt from secret scanning
     * Find all repos exempt from secret scan
     */
    async findExemptReposByScopeRaw(requestParameters: FindExemptReposByScopeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoriesRecentlyAccessed200Response>> {
        const queryParameters: any = {};

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/secret-scanning/exempt`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find all repositories exempt from secret scanning
     * Find all repos exempt from secret scan
     */
    async findExemptReposByScope(requestParameters: FindExemptReposByScopeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoriesRecentlyAccessed200Response> {
        const response = await this.findExemptReposByScopeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a project secret scanning allowlist rule by ID.  Project **Admin** is required
     * Get a project secret scanning allowlist rule
     */
    async getAllowlistRuleRaw(requestParameters: GetAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningAllowlistRule>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getAllowlistRule.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getAllowlistRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/allowlist/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a project secret scanning allowlist rule by ID.  Project **Admin** is required
     * Get a project secret scanning allowlist rule
     */
    async getAllowlistRule(requestParameters: GetAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningAllowlistRule> {
        const response = await this.getAllowlistRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a repository secret scanning allowlist rule by ID.  Repository **Admin** is required
     * Get a repository secret scanning allowlist rule
     */
    async getAllowlistRule1Raw(requestParameters: GetAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningAllowlistRule>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getAllowlistRule1.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getAllowlistRule1.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling getAllowlistRule1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/allowlist/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a repository secret scanning allowlist rule by ID.  Repository **Admin** is required
     * Get a repository secret scanning allowlist rule
     */
    async getAllowlistRule1(requestParameters: GetAllowlistRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningAllowlistRule> {
        const response = await this.getAllowlistRule1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find all the keys for the currently authenticated user. Optionally, users with ADMIN and higher permissions may choose to specify the <code>user</code> parameter to retrieve GPG keys for another user.  Only authenticated users may call this endpoint.
     * Get all GPG keys
     */
    async getKeysForUserRaw(requestParameters: GetKeysForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetKeysForUser200Response>> {
        const queryParameters: any = {};

        if (requestParameters.user !== undefined) {
            queryParameters['user'] = requestParameters.user;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/gpg/latest/keys`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find all the keys for the currently authenticated user. Optionally, users with ADMIN and higher permissions may choose to specify the <code>user</code> parameter to retrieve GPG keys for another user.  Only authenticated users may call this endpoint.
     * Get all GPG keys
     */
    async getKeysForUser(requestParameters: GetKeysForUserRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetKeysForUser200Response> {
        const response = await this.getKeysForUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a project secret scanning rule by ID.  Project **Admin** is required
     * Get a project secret scanning rule
     */
    async getRuleRaw(requestParameters: GetRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getRule.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/rules/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a project secret scanning rule by ID.  Project **Admin** is required
     * Get a project secret scanning rule
     */
    async getRule(requestParameters: GetRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.getRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a repository secret scanning rule by ID.  Repository **Admin** is required
     * Get a repository secret scanning rule
     */
    async getRule1Raw(requestParameters: GetRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getRule1.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getRule1.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling getRule1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/rules/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a repository secret scanning rule by ID.  Repository **Admin** is required
     * Get a repository secret scanning rule
     */
    async getRule1(requestParameters: GetRule1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.getRule1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a global secret scanning rule by ID.
     * Get a global secret scanning rule
     */
    async getRule2Raw(requestParameters: GetRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecretScanningRule>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getRule2.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/secret-scanning/rules/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a global secret scanning rule by ID.
     * Get a global secret scanning rule
     */
    async getRule2(requestParameters: GetRule2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecretScanningRule> {
        const response = await this.getRule2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check whether a repository is exempt from secret scanning
     * Get whether a repository is exempt
     */
    async isRepoExemptRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/exempt`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Check whether a repository is exempt from secret scanning
     * Get whether a repository is exempt
     */
    async isRepoExempt(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.isRepoExemptRaw(initOverrides);
    }

    /**
     * Find project secret scanning rules by filtering.  Project **Admin** is required
     * Find project secret scanning rules
     */
    async search1Raw(requestParameters: Search1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Search3200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling search1.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/rules`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find project secret scanning rules by filtering.  Project **Admin** is required
     * Find project secret scanning rules
     */
    async search1(requestParameters: Search1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Search3200Response> {
        const response = await this.search1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find repository secret scanning allowlist rules by filtering.  Repository **Admin** is required
     * Find repository secret scanning allowlist rules
     */
    async search2Raw(requestParameters: Search2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Search2200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling search2.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling search2.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/allowlist`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find repository secret scanning allowlist rules by filtering.  Repository **Admin** is required
     * Find repository secret scanning allowlist rules
     */
    async search2(requestParameters: Search2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Search2200Response> {
        const response = await this.search2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find repository secret scanning rules by filtering.  Repository **Admin** is required
     * Find repository secret scanning rules
     */
    async search3Raw(requestParameters: Search3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Search3200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling search3.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling search3.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/secret-scanning/rules`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find repository secret scanning rules by filtering.  Repository **Admin** is required
     * Find repository secret scanning rules
     */
    async search3(requestParameters: Search3Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Search3200Response> {
        const response = await this.search3Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find global secret scanning rules by filtering.
     * Find global secret scanning rules
     */
    async search4Raw(requestParameters: Search4Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Search3200Response>> {
        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/secret-scanning/rules`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find global secret scanning rules by filtering.
     * Find global secret scanning rules
     */
    async search4(requestParameters: Search4Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Search3200Response> {
        const response = await this.search4Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find project secret scanning allowlist rules by filtering.  Project **Admin** is required
     * Find project secret scanning allowlist rules
     */
    async searchAllowlistRuleRaw(requestParameters: SearchAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Search2200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling searchAllowlistRule.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/secret-scanning/allowlist`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find project secret scanning allowlist rules by filtering.  Project **Admin** is required
     * Find project secret scanning allowlist rules
     */
    async searchAllowlistRule(requestParameters: SearchAllowlistRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Search2200Response> {
        const response = await this.searchAllowlistRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const FindExemptReposByProjectOrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type FindExemptReposByProjectOrderEnum = typeof FindExemptReposByProjectOrderEnum[keyof typeof FindExemptReposByProjectOrderEnum];
/**
 * @export
 */
export const FindExemptReposByScopeOrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type FindExemptReposByScopeOrderEnum = typeof FindExemptReposByScopeOrderEnum[keyof typeof FindExemptReposByScopeOrderEnum];
/**
 * @export
 */
export const Search1OrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type Search1OrderEnum = typeof Search1OrderEnum[keyof typeof Search1OrderEnum];
/**
 * @export
 */
export const Search2OrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type Search2OrderEnum = typeof Search2OrderEnum[keyof typeof Search2OrderEnum];
/**
 * @export
 */
export const Search3OrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type Search3OrderEnum = typeof Search3OrderEnum[keyof typeof Search3OrderEnum];
/**
 * @export
 */
export const Search4OrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type Search4OrderEnum = typeof Search4OrderEnum[keyof typeof Search4OrderEnum];
/**
 * @export
 */
export const SearchAllowlistRuleOrderEnum = {
    Asc: 'NAME_ASC',
    Desc: 'NAME_DESC'
} as const;
export type SearchAllowlistRuleOrderEnum = typeof SearchAllowlistRuleOrderEnum[keyof typeof SearchAllowlistRuleOrderEnum];
