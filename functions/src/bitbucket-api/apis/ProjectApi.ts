/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Server
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 8.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ExampleSettings,
  GetAll401Response,
  GetConfigurations200Response,
  GetGroups1200Response,
  GetGroupsWithAnyPermission200Response,
  GetLikers200Response,
  GetProjects200Response,
  GetRepositoriesRecentlyAccessed200Response,
  GetRepositoryHooks1200Response,
  GetRestrictions1200Response,
  GetUsersWithAnyPermission1200Response,
  RestAutoDeclineSettings,
  RestAutoDeclineSettingsRequest,
  RestBranch,
  RestHookScriptConfig,
  RestHookScriptTriggers,
  RestMinimalRef,
  RestPermitted,
  RestProject,
  RestPullRequestSettings,
  RestRefRestriction,
  RestRepository,
  RestRepositoryHook,
  RestRestrictionRequest,
} from '../models';

interface DeleteRequest {
    projectKey: string;
}

interface CreateProjectRequest {
    restProject?: RestProject;
}

interface CreateRepositoryRequest {
    projectKey: string;
    restRepository?: RestRepository;
}

interface CreateRestrictionRequest {
    projectKey: string;
    restRestrictionRequest?: RestRestrictionRequest;
}

interface DeleteProjectRequest {
    projectKey: string;
}

interface DeleteRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
}

interface DeleteRestrictionRequest {
    projectKey: string;
    id: string;
}

interface DisableHookRequest {
    projectKey: string;
    hookKey: string;
}

interface EnableHookRequest {
    projectKey: string;
    hookKey: string;
    contentLength?: number;
}

interface ForkRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
    restRepository?: RestRepository;
}

interface GetRequest {
    projectKey: string;
}

interface GetAvatarRequest {
    hookKey: string;
    version?: string;
}

interface GetConfigurationsRequest {
    projectKey: string;
    start?: number;
    limit?: number;
}

interface GetDefaultBranch2Request {
    projectKey: string;
    repositorySlug: string;
}

interface GetForkedRepositoriesRequest {
    projectKey: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface GetGroupsWithAnyPermission1Request {
    projectKey: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetGroupsWithoutAnyPermission1Request {
    projectKey: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetProjectRequest {
    projectKey: string;
}

interface GetProjectAvatarRequest {
    projectKey: string;
    s?: string;
}

interface GetProjectsRequest {
    name?: string;
    permission?: string;
    start?: number;
    limit?: number;
}

interface GetPullRequestSettingsRequest {
    projectKey: string;
    scmId: string;
}

interface GetRelatedRepositoriesRequest {
    projectKey: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface GetRepositoriesRequest {
    projectKey: string;
    start?: number;
    limit?: number;
}

interface GetRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
}

interface GetRepositoryHookRequest {
    projectKey: string;
    hookKey: string;
}

interface GetRepositoryHooksRequest {
    projectKey: string;
    type?: GetRepositoryHooksTypeEnum;
    start?: number;
    limit?: number;
}

interface GetRestrictionRequest {
    projectKey: string;
    id: string;
}

interface GetRestrictionsRequest {
    projectKey: string;
    matcherType?: GetRestrictionsMatcherTypeEnum;
    matcherId?: string;
    type?: GetRestrictionsTypeEnum;
    start?: number;
    limit?: number;
}

interface GetSettingsRequest {
    projectKey: string;
    hookKey: string;
}

interface GetUsersWithAnyPermission1Request {
    projectKey: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface GetUsersWithoutPermissionRequest {
    projectKey: string;
    filter?: string;
    start?: number;
    limit?: number;
}

interface HasAllUserPermissionRequest {
    projectKey: string;
    permission: string;
}

interface ModifyAllUserPermissionRequest {
    projectKey: string;
    permission: string;
    allow?: string;
}

interface RemoveConfigurationRequest {
    projectKey: string;
    scriptId: string;
}

interface RetryCreateRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
}

interface RevokePermissionsRequest {
    projectKey: string;
    user?: string;
    group?: string;
}

interface RevokePermissionsForGroup1Request {
    projectKey: string;
    name?: string;
}

interface RevokePermissionsForUser1Request {
    projectKey: string;
    name?: string;
}

interface SearchPermissionsRequest {
    projectKey: string;
    permission?: string;
    filterText?: string;
    type?: string;
}

interface SetRequest {
    projectKey: string;
    restAutoDeclineSettingsRequest?: RestAutoDeclineSettingsRequest;
}

interface SetConfigurationRequest {
    projectKey: string;
    scriptId: string;
    restHookScriptTriggers?: RestHookScriptTriggers;
}

interface SetDefaultBranch2Request {
    projectKey: string;
    repositorySlug: string;
    restBranch?: RestBranch;
}

interface SetPermissionForGroups1Request {
    projectKey: string;
    name?: string;
    permission?: string;
}

interface SetPermissionForUsers1Request {
    projectKey: string;
    name?: string;
    permission?: string;
}

interface SetSettingsRequest {
    projectKey: string;
    hookKey: string;
    exampleSettings?: ExampleSettings;
}

interface StreamContributingRequest {
    projectKey: string;
    repositorySlug: string;
    at?: string;
    markup?: string;
    htmlEscape?: string;
    includeHeadingId?: string;
    hardwrap?: string;
}

interface StreamLicenseRequest {
    projectKey: string;
    repositorySlug: string;
    at?: string;
    markup?: string;
    htmlEscape?: string;
    includeHeadingId?: string;
    hardwrap?: string;
}

interface StreamReadmeRequest {
    projectKey: string;
    repositorySlug: string;
    at?: string;
    markup?: string;
    htmlEscape?: string;
    includeHeadingId?: string;
    hardwrap?: string;
}

interface UpdateProjectRequest {
    projectKey: string;
    restProject?: RestProject;
}

interface UpdatePullRequestSettingsRequest {
    projectKey: string;
    scmId: string;
    restPullRequestSettings?: RestPullRequestSettings;
}

interface UpdateRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
    restRepository?: RestRepository;
}

interface UploadAvatarRequest {
    projectKey: string;
    avatar?: Blob;
}

/**
 * 
 */
export class ProjectApi extends runtime.BaseAPI {

    /**
     * Delete auto decline settings for the supplied project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for this project to call the resource.
     * Delete auto decline settings
     */
    async _deleteRaw(requestParameters: DeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling _delete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/auto-decline`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete auto decline settings for the supplied project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for this project to call the resource.
     * Delete auto decline settings
     */
    async _delete(requestParameters: DeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this._deleteRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new project.   To include a custom avatar for the project, the project definition should contain an additional attribute with the key <code>avatar</code> and the value a data URI containing Base64-encoded image data. The URI should be in the following format: <pre>    data:(content type, e.g. image/png);base64,(data) </pre>If the data is not Base64-encoded, or if a character set is defined in the URI, or the URI is otherwise invalid, <em>project creation will fail</em>.   The authenticated user must have <strong>PROJECT_CREATE</strong> permission to call this resource.
     * Create a new project
     */
    async createProjectRaw(requestParameters: CreateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestProject>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restProject,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new project.   To include a custom avatar for the project, the project definition should contain an additional attribute with the key <code>avatar</code> and the value a data URI containing Base64-encoded image data. The URI should be in the following format: <pre>    data:(content type, e.g. image/png);base64,(data) </pre>If the data is not Base64-encoded, or if a character set is defined in the URI, or the URI is otherwise invalid, <em>project creation will fail</em>.   The authenticated user must have <strong>PROJECT_CREATE</strong> permission to call this resource.
     * Create a new project
     */
    async createProject(requestParameters: CreateProjectRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestProject> {
        const response = await this.createProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new repository. Requires an existing project in which this repository will be created. The only parameters which will be used are name and scmId.   The authenticated user must have <strong>REPO_CREATE</strong> permission or higher, for the context project to call this resource.
     * Create repository
     */
    async createRepositoryRaw(requestParameters: CreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepository>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling createRepository.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restRepository,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new repository. Requires an existing project in which this repository will be created. The only parameters which will be used are name and scmId.   The authenticated user must have <strong>REPO_CREATE</strong> permission or higher, for the context project to call this resource.
     * Create repository
     */
    async createRepository(requestParameters: CreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepository> {
        const response = await this.createRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a restriction for the supplied branch or set of branches to be applied on all repositories in the given project.  A restriction means preventing writes on the specified branch(es) by all except a set of users and/or groups, or preventing specific operations such as branch deletion.  For example, you can restrict write access on \'master\' to just the \'senior-developer\' group, or prevent anyone from deleting that branch.  The request matcher and type must conform to the following.  - The matcher can be one of the following types    - \'BRANCH\' represents a specific Branch name. You must supply the fully qualified name of the ref to restrict, e.g. \"refs/heads/master\"       instead of \"master\".    - \'PATTERN\' represents a wildcard pattern that may match multiple branches. You must specify a valid       <a href=\"https://confluence.atlassian.com/display/STASH/Branch+permission+patterns\">Branch Permission Pattern</a>.    - \'MODEL_CATEGORY\' represents Branch prefixes in the Branching model for the project. The \'id\' must be one of        - \'FEATURE\'        - \'BUGFIX\'        - \'HOTFIX\'        - \'RELEASE\'   See the Branch REST API for more information.  - \'MODEL_BRANCH\' represents either the Development or Production branch in the branching model for the project. The \'id\' must be one of    - \'development\'    - \'production\'   See the Branch REST API for more information.   - Type: Set and be one of     - \'pull-request-only\'    - \'fast-forward-only\'    - \'no-deletes\'    - \'read-only\'   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Create a ref restriction
     */
    async createRestrictionRaw(requestParameters: CreateRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRefRestriction>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling createRestriction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/branch-permissions/latest/projects/{projectKey}/restrictions`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restRestrictionRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a restriction for the supplied branch or set of branches to be applied on all repositories in the given project.  A restriction means preventing writes on the specified branch(es) by all except a set of users and/or groups, or preventing specific operations such as branch deletion.  For example, you can restrict write access on \'master\' to just the \'senior-developer\' group, or prevent anyone from deleting that branch.  The request matcher and type must conform to the following.  - The matcher can be one of the following types    - \'BRANCH\' represents a specific Branch name. You must supply the fully qualified name of the ref to restrict, e.g. \"refs/heads/master\"       instead of \"master\".    - \'PATTERN\' represents a wildcard pattern that may match multiple branches. You must specify a valid       <a href=\"https://confluence.atlassian.com/display/STASH/Branch+permission+patterns\">Branch Permission Pattern</a>.    - \'MODEL_CATEGORY\' represents Branch prefixes in the Branching model for the project. The \'id\' must be one of        - \'FEATURE\'        - \'BUGFIX\'        - \'HOTFIX\'        - \'RELEASE\'   See the Branch REST API for more information.  - \'MODEL_BRANCH\' represents either the Development or Production branch in the branching model for the project. The \'id\' must be one of    - \'development\'    - \'production\'   See the Branch REST API for more information.   - Type: Set and be one of     - \'pull-request-only\'    - \'fast-forward-only\'    - \'no-deletes\'    - \'read-only\'   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Create a ref restriction
     */
    async createRestriction(requestParameters: CreateRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRefRestriction> {
        const response = await this.createRestrictionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the project matching the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Delete project
     */
    async deleteProjectRaw(requestParameters: DeleteProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling deleteProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the project matching the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Delete project
     */
    async deleteProject(requestParameters: DeleteProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteProjectRaw(requestParameters, initOverrides);
    }

    /**
     * Schedule the repository matching the supplied <strong>projectKey</strong> and <strong>repositorySlug</strong> to be deleted.   The authenticated user must have sufficient permissions specified by the repository delete policy to call this resource. The default permission required is <strong>REPO_ADMIN</strong> permission.
     * Delete repository
     */
    async deleteRepositoryRaw(requestParameters: DeleteRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling deleteRepository.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling deleteRepository.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Schedule the repository matching the supplied <strong>projectKey</strong> and <strong>repositorySlug</strong> to be deleted.   The authenticated user must have sufficient permissions specified by the repository delete policy to call this resource. The default permission required is <strong>REPO_ADMIN</strong> permission.
     * Delete repository
     */
    async deleteRepository(requestParameters: DeleteRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRepositoryRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a restriction as specified by a restriction id.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Delete a ref restriction
     */
    async deleteRestrictionRaw(requestParameters: DeleteRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling deleteRestriction.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteRestriction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/branch-permissions/latest/projects/{projectKey}/restrictions/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a restriction as specified by a restriction id.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Delete a ref restriction
     */
    async deleteRestriction(requestParameters: DeleteRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRestrictionRaw(requestParameters, initOverrides);
    }

    /**
     * Disable a repository hook for this project.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Disable repository hook
     */
    async disableHookRaw(requestParameters: DisableHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryHook>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling disableHook.');
        }

        if (requestParameters.hookKey === null || requestParameters.hookKey === undefined) {
            throw new runtime.RequiredError('hookKey','Required parameter requestParameters.hookKey was null or undefined when calling disableHook.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/hooks/{hookKey}/enabled`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters.hookKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Disable a repository hook for this project.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Disable repository hook
     */
    async disableHook(requestParameters: DisableHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryHook> {
        const response = await this.disableHookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enable a repository hook for this project and optionally apply new configuration.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.   A JSON document may be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.
     * Enable repository hook
     */
    async enableHookRaw(requestParameters: EnableHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryHook>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling enableHook.');
        }

        if (requestParameters.hookKey === null || requestParameters.hookKey === undefined) {
            throw new runtime.RequiredError('hookKey','Required parameter requestParameters.hookKey was null or undefined when calling enableHook.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.contentLength !== undefined && requestParameters.contentLength !== null) {
            headerParameters['Content-Length'] = String(requestParameters.contentLength);
        }

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/hooks/{hookKey}/enabled`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters.hookKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Enable a repository hook for this project and optionally apply new configuration.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.   A JSON document may be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.
     * Enable repository hook
     */
    async enableHook(requestParameters: EnableHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryHook> {
        const response = await this.enableHookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new repository forked from an existing repository.   The JSON body for this <code>POST</code> is not required to contain <i>any</i> properties. Even the name may be omitted. The following properties will be used, if provided:   - <code>\"name\":\"Fork name\"</code> - Specifies the forked repository\'s name    - Defaults to the name of the origin repository if not specified - <code>\"defaultBranch\":\"main\"</code> - Specifies the forked repository\'s default branch   - Defaults to the origin repository\'s default branch if not specified - <code>\"project\":{\"key\":\"TARGET_KEY\"}</code> - Specifies the forked repository\'s target project by key   - Defaults to the current user\'s personal project if not specified   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository and <strong>PROJECT_ADMIN</strong> on the target project to call this resource. Note that users <i>always</i> have <b>PROJECT_ADMIN</b> permission on their personal projects.
     * Fork repository
     */
    async forkRepositoryRaw(requestParameters: ForkRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepository>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling forkRepository.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling forkRepository.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restRepository,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new repository forked from an existing repository.   The JSON body for this <code>POST</code> is not required to contain <i>any</i> properties. Even the name may be omitted. The following properties will be used, if provided:   - <code>\"name\":\"Fork name\"</code> - Specifies the forked repository\'s name    - Defaults to the name of the origin repository if not specified - <code>\"defaultBranch\":\"main\"</code> - Specifies the forked repository\'s default branch   - Defaults to the origin repository\'s default branch if not specified - <code>\"project\":{\"key\":\"TARGET_KEY\"}</code> - Specifies the forked repository\'s target project by key   - Defaults to the current user\'s personal project if not specified   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository and <strong>PROJECT_ADMIN</strong> on the target project to call this resource. Note that users <i>always</i> have <b>PROJECT_ADMIN</b> permission on their personal projects.
     * Fork repository
     */
    async forkRepository(requestParameters: ForkRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepository> {
        const response = await this.forkRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the auto decline settings for the supplied project. Default settings are returned if no explicit settings have been set for the project.
     * Get auto decline settings
     */
    async getRaw(requestParameters: GetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAutoDeclineSettings>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling get.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/auto-decline`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the auto decline settings for the supplied project. Default settings are returned if no explicit settings have been set for the project.
     * Get auto decline settings
     */
    async get(requestParameters: GetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAutoDeclineSettings> {
        const response = await this.getRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the avatar for the project matching the supplied <strong>moduleKey</strong>.
     * Get project avatar
     */
    async getAvatarRaw(requestParameters: GetAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.hookKey === null || requestParameters.hookKey === undefined) {
            throw new runtime.RequiredError('hookKey','Required parameter requestParameters.hookKey was null or undefined when calling getAvatar.');
        }

        const queryParameters: any = {};

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/hooks/{hookKey}/avatar`.replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters.hookKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve the avatar for the project matching the supplied <strong>moduleKey</strong>.
     * Get project avatar
     */
    async getAvatar(requestParameters: GetAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getAvatarRaw(requestParameters, initOverrides);
    }

    /**
     * Return a page of hook scripts configured for the specified project.   This endpoint requires **PROJECT_ADMIN** permission.
     * Get configured hook scripts
     */
    async getConfigurationsRaw(requestParameters: GetConfigurationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetConfigurations200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getConfigurations.');
        }

        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/hook-scripts`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Return a page of hook scripts configured for the specified project.   This endpoint requires **PROJECT_ADMIN** permission.
     * Get configured hook scripts
     */
    async getConfigurations(requestParameters: GetConfigurationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetConfigurations200Response> {
        const response = await this.getConfigurationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the repository\'s <i>configured</i> default branch.   Every repository has a <i>configured</i> default branch, but that branch may not actually <i>exist</i> in the repository. For example, a newly-created repository will have a configured default branch even though no branches have been pushed yet.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository default branch
     */
    async getDefaultBranch2Raw(requestParameters: GetDefaultBranch2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMinimalRef>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getDefaultBranch2.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling getDefaultBranch2.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/default-branch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the repository\'s <i>configured</i> default branch.   Every repository has a <i>configured</i> default branch, but that branch may not actually <i>exist</i> in the repository. For example, a newly-created repository will have a configured default branch even though no branches have been pushed yet.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository default branch
     */
    async getDefaultBranch2(requestParameters: GetDefaultBranch2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMinimalRef> {
        const response = await this.getDefaultBranch2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve repositories which have been forked from this one. Unlike #getRelatedRepositories(Repository, PageRequest) related repositories, this only looks at a given repository\'s direct forks. If those forks have themselves been the origin of more forks, such \"grandchildren\" repositories will not be retrieved.   Only repositories to which the authenticated user has <b>REPO_READ</b> permission will be included, even if other repositories have been forked from this one.
     * Get repository forks
     */
    async getForkedRepositoriesRaw(requestParameters: GetForkedRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoriesRecentlyAccessed200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getForkedRepositories.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling getForkedRepositories.');
        }

        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/forks`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve repositories which have been forked from this one. Unlike #getRelatedRepositories(Repository, PageRequest) related repositories, this only looks at a given repository\'s direct forks. If those forks have themselves been the origin of more forks, such \"grandchildren\" repositories will not be retrieved.   Only repositories to which the authenticated user has <b>REPO_READ</b> permission will be included, even if other repositories have been forked from this one.
     * Get repository forks
     */
    async getForkedRepositories(requestParameters: GetForkedRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoriesRecentlyAccessed200Response> {
        const response = await this.getForkedRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of groups that have been granted at least one permission for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Get groups with permission to project
     */
    async getGroupsWithAnyPermission1Raw(requestParameters: GetGroupsWithAnyPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGroupsWithAnyPermission200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getGroupsWithAnyPermission1.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of groups that have been granted at least one permission for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Get groups with permission to project
     */
    async getGroupsWithAnyPermission1(requestParameters: GetGroupsWithAnyPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGroupsWithAnyPermission200Response> {
        const response = await this.getGroupsWithAnyPermission1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of groups that have no granted permissions for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher
     * Get groups without project permission
     */
    async getGroupsWithoutAnyPermission1Raw(requestParameters: GetGroupsWithoutAnyPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetGroups1200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getGroupsWithoutAnyPermission1.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/groups/none`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of groups that have no granted permissions for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher
     * Get groups without project permission
     */
    async getGroupsWithoutAnyPermission1(requestParameters: GetGroupsWithoutAnyPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetGroups1200Response> {
        const response = await this.getGroupsWithoutAnyPermission1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the project matching the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_VIEW</strong> permission for the specified project to call this resource.
     * Get a project
     */
    async getProjectRaw(requestParameters: GetProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestProject>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the project matching the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_VIEW</strong> permission for the specified project to call this resource.
     * Get a project
     */
    async getProject(requestParameters: GetProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestProject> {
        const response = await this.getProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the avatar for the project matching the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_VIEW</strong> permission for the specified project to call this resource.
     * Get avatar for project
     */
    async getProjectAvatarRaw(requestParameters: GetProjectAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getProjectAvatar.');
        }

        const queryParameters: any = {};

        if (requestParameters.s !== undefined) {
            queryParameters['s'] = requestParameters.s;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/avatar.png`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve the avatar for the project matching the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_VIEW</strong> permission for the specified project to call this resource.
     * Get avatar for project
     */
    async getProjectAvatar(requestParameters: GetProjectAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getProjectAvatarRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve a page of projects.   Only projects for which the authenticated user has the <strong>PROJECT_VIEW</strong> permission will be returned.
     * Get projects
     */
    async getProjectsRaw(requestParameters: GetProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetProjects200Response>> {
        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.permission !== undefined) {
            queryParameters['permission'] = requestParameters.permission;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of projects.   Only projects for which the authenticated user has the <strong>PROJECT_VIEW</strong> permission will be returned.
     * Get projects
     */
    async getProjects(requestParameters: GetProjectsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetProjects200Response> {
        const response = await this.getProjectsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the merge strategy configuration for this project and SCM.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the context repository to call this resource.
     * Get merge strategy
     */
    async getPullRequestSettingsRaw(requestParameters: GetPullRequestSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestSettings>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getPullRequestSettings.');
        }

        if (requestParameters.scmId === null || requestParameters.scmId === undefined) {
            throw new runtime.RequiredError('scmId','Required parameter requestParameters.scmId was null or undefined when calling getPullRequestSettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/pull-requests/{scmId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"scmId"}}`, encodeURIComponent(String(requestParameters.scmId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the merge strategy configuration for this project and SCM.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the context repository to call this resource.
     * Get merge strategy
     */
    async getPullRequestSettings(requestParameters: GetPullRequestSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestSettings> {
        const response = await this.getPullRequestSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve repositories which are related to this one. Related repositories are from the same Repository#getHierarchyId() hierarchy as this repository.   Only repositories to which the authenticated user has <b>REPO_READ</b> permission will be included, even if more repositories are part of this repository\'s hierarchy.
     * Get related repository
     */
    async getRelatedRepositoriesRaw(requestParameters: GetRelatedRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoriesRecentlyAccessed200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getRelatedRepositories.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling getRelatedRepositories.');
        }

        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/related`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve repositories which are related to this one. Related repositories are from the same Repository#getHierarchyId() hierarchy as this repository.   Only repositories to which the authenticated user has <b>REPO_READ</b> permission will be included, even if more repositories are part of this repository\'s hierarchy.
     * Get related repository
     */
    async getRelatedRepositories(requestParameters: GetRelatedRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoriesRecentlyAccessed200Response> {
        const response = await this.getRelatedRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve repositories from the project corresponding to the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get repositories for project
     */
    async getRepositoriesRaw(requestParameters: GetRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoriesRecentlyAccessed200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getRepositories.');
        }

        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve repositories from the project corresponding to the supplied <strong>projectKey</strong>.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get repositories for project
     */
    async getRepositories(requestParameters: GetRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoriesRecentlyAccessed200Response> {
        const response = await this.getRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the repository matching the supplied <strong>projectKey</strong> and <strong>repositorySlug</strong>.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository
     */
    async getRepositoryRaw(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepository>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getRepository.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling getRepository.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the repository matching the supplied <strong>projectKey</strong> and <strong>repositorySlug</strong>.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository
     */
    async getRepository(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepository> {
        const response = await this.getRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a repository hook for this project.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get a repository hook
     */
    async getRepositoryHookRaw(requestParameters: GetRepositoryHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryHook>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getRepositoryHook.');
        }

        if (requestParameters.hookKey === null || requestParameters.hookKey === undefined) {
            throw new runtime.RequiredError('hookKey','Required parameter requestParameters.hookKey was null or undefined when calling getRepositoryHook.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/hooks/{hookKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters.hookKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a repository hook for this project.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get a repository hook
     */
    async getRepositoryHook(requestParameters: GetRepositoryHookRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryHook> {
        const response = await this.getRepositoryHookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of repository hooks for this project.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get repository hooks
     */
    async getRepositoryHooksRaw(requestParameters: GetRepositoryHooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepositoryHooks1200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getRepositoryHooks.');
        }

        const queryParameters: any = {};

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/hooks`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of repository hooks for this project.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get repository hooks
     */
    async getRepositoryHooks(requestParameters: GetRepositoryHooksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepositoryHooks1200Response> {
        const response = await this.getRepositoryHooksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a restriction as specified by a restriction id.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Get a ref restriction
     */
    async getRestrictionRaw(requestParameters: GetRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRefRestriction>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getRestriction.');
        }

        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getRestriction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/branch-permissions/latest/projects/{projectKey}/restrictions/{id}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a restriction as specified by a restriction id.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Get a ref restriction
     */
    async getRestriction(requestParameters: GetRestrictionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRefRestriction> {
        const response = await this.getRestrictionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for restrictions using the supplied parameters.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Search for ref restrictions
     */
    async getRestrictionsRaw(requestParameters: GetRestrictionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRestrictions1200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getRestrictions.');
        }

        const queryParameters: any = {};

        if (requestParameters.matcherType !== undefined) {
            queryParameters['matcherType'] = requestParameters.matcherType;
        }

        if (requestParameters.matcherId !== undefined) {
            queryParameters['matcherId'] = requestParameters.matcherId;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/branch-permissions/latest/projects/{projectKey}/restrictions`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search for restrictions using the supplied parameters.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this resource. Only authenticated users may call this resource.
     * Search for ref restrictions
     */
    async getRestrictions(requestParameters: GetRestrictionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRestrictions1200Response> {
        const response = await this.getRestrictionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the settings for a repository hook for this project.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get repository hook settings
     */
    async getSettingsRaw(requestParameters: GetSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExampleSettings>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getSettings.');
        }

        if (requestParameters.hookKey === null || requestParameters.hookKey === undefined) {
            throw new runtime.RequiredError('hookKey','Required parameter requestParameters.hookKey was null or undefined when calling getSettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/hooks/{hookKey}/settings`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters.hookKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the settings for a repository hook for this project.   The authenticated user must have <strong>PROJECT_READ</strong> permission for the specified project to call this resource.
     * Get repository hook settings
     */
    async getSettings(requestParameters: GetSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExampleSettings> {
        const response = await this.getSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of users that have been granted at least one permission for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Get users with permission to project
     */
    async getUsersWithAnyPermission1Raw(requestParameters: GetUsersWithAnyPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetUsersWithAnyPermission1200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getUsersWithAnyPermission1.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/users`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of users that have been granted at least one permission for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Get users with permission to project
     */
    async getUsersWithAnyPermission1(requestParameters: GetUsersWithAnyPermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetUsersWithAnyPermission1200Response> {
        const response = await this.getUsersWithAnyPermission1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of <i>licensed</i> users that have no granted permissions for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Get users without project permission
     */
    async getUsersWithoutPermissionRaw(requestParameters: GetUsersWithoutPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetLikers200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getUsersWithoutPermission.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/users/none`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of <i>licensed</i> users that have no granted permissions for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Get users without project permission
     */
    async getUsersWithoutPermission(requestParameters: GetUsersWithoutPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetLikers200Response> {
        const response = await this.getUsersWithoutPermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check whether the specified permission is the default permission (granted to all users) for a project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Check default project permission
     */
    async hasAllUserPermissionRaw(requestParameters: HasAllUserPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPermitted>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling hasAllUserPermission.');
        }

        if (requestParameters.permission === null || requestParameters.permission === undefined) {
            throw new runtime.RequiredError('permission','Required parameter requestParameters.permission was null or undefined when calling hasAllUserPermission.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/{permission}/all`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"permission"}}`, encodeURIComponent(String(requestParameters.permission))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Check whether the specified permission is the default permission (granted to all users) for a project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Check default project permission
     */
    async hasAllUserPermission(requestParameters: HasAllUserPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPermitted> {
        const response = await this.hasAllUserPermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Grant or revoke a project permission to all users, i.e. set the default permission.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Grant project permission
     */
    async modifyAllUserPermissionRaw(requestParameters: ModifyAllUserPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling modifyAllUserPermission.');
        }

        if (requestParameters.permission === null || requestParameters.permission === undefined) {
            throw new runtime.RequiredError('permission','Required parameter requestParameters.permission was null or undefined when calling modifyAllUserPermission.');
        }

        const queryParameters: any = {};

        if (requestParameters.allow !== undefined) {
            queryParameters['allow'] = requestParameters.allow;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/{permission}/all`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"permission"}}`, encodeURIComponent(String(requestParameters.permission))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Grant or revoke a project permission to all users, i.e. set the default permission.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Grant project permission
     */
    async modifyAllUserPermission(requestParameters: ModifyAllUserPermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.modifyAllUserPermissionRaw(requestParameters, initOverrides);
    }

    /**
     * Removes the hook script from the set of hook scripts configured to run in all repositories under the project.   This endpoint requires **PROJECT_ADMIN** permission.
     * Remove a hook script
     */
    async removeConfigurationRaw(requestParameters: RemoveConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling removeConfiguration.');
        }

        if (requestParameters.scriptId === null || requestParameters.scriptId === undefined) {
            throw new runtime.RequiredError('scriptId','Required parameter requestParameters.scriptId was null or undefined when calling removeConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/hook-scripts/{scriptId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"scriptId"}}`, encodeURIComponent(String(requestParameters.scriptId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Removes the hook script from the set of hook scripts configured to run in all repositories under the project.   This endpoint requires **PROJECT_ADMIN** permission.
     * Remove a hook script
     */
    async removeConfiguration(requestParameters: RemoveConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeConfigurationRaw(requestParameters, initOverrides);
    }

    /**
     * If a create or fork operation fails, calling this method will clean up the broken repository and try again. The repository must be in an INITIALISATION_FAILED state.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Retry repository creation
     */
    async retryCreateRepositoryRaw(requestParameters: RetryCreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepository>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling retryCreateRepository.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling retryCreateRepository.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/recreate`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * If a create or fork operation fails, calling this method will clean up the broken repository and try again. The repository must be in an INITIALISATION_FAILED state.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Retry repository creation
     */
    async retryCreateRepository(requestParameters: RetryCreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepository> {
        const response = await this.retryCreateRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Revoke all permissions for the specified project for the given groups and users.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.  In addition, a user may not revoke a group\'s permission if their own permission would be revoked as a result, nor may they revoke their own permission unless they have a global permission that already implies that permission.
     * Revoke project permissions
     */
    async revokePermissionsRaw(requestParameters: RevokePermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling revokePermissions.');
        }

        const queryParameters: any = {};

        if (requestParameters.user !== undefined) {
            queryParameters['user'] = requestParameters.user;
        }

        if (requestParameters.group !== undefined) {
            queryParameters['group'] = requestParameters.group;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke all permissions for the specified project for the given groups and users.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.  In addition, a user may not revoke a group\'s permission if their own permission would be revoked as a result, nor may they revoke their own permission unless they have a global permission that already implies that permission.
     * Revoke project permissions
     */
    async revokePermissions(requestParameters: RevokePermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokePermissionsRaw(requestParameters, initOverrides);
    }

    /**
     *  Revoke all permissions for the specified project for a group.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.  In addition, a user may not revoke a group\'s permissions if it will reduce their own permission level.
     * Revoke group project permission
     */
    async revokePermissionsForGroup1Raw(requestParameters: RevokePermissionsForGroup1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling revokePermissionsForGroup1.');
        }

        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     *  Revoke all permissions for the specified project for a group.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.  In addition, a user may not revoke a group\'s permissions if it will reduce their own permission level.
     * Revoke group project permission
     */
    async revokePermissionsForGroup1(requestParameters: RevokePermissionsForGroup1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokePermissionsForGroup1Raw(requestParameters, initOverrides);
    }

    /**
     * Revoke all permissions for the specified project for a user.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.  In addition, a user may not revoke their own project permissions if they do not have a higher global permission.
     * Revoke user project permission
     */
    async revokePermissionsForUser1Raw(requestParameters: RevokePermissionsForUser1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling revokePermissionsForUser1.');
        }

        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/users`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke all permissions for the specified project for a user.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.  In addition, a user may not revoke their own project permissions if they do not have a higher global permission.
     * Revoke user project permission
     */
    async revokePermissionsForUser1(requestParameters: RevokePermissionsForUser1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokePermissionsForUser1Raw(requestParameters, initOverrides);
    }

    /**
     * Search direct and implied permissions of principals (users and groups). This endpoint returns a superset of the results returned by the /users and /groups endpoints because it allows filtering by global permissions too.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Search project permissions
     */
    async searchPermissionsRaw(requestParameters: SearchPermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling searchPermissions.');
        }

        const queryParameters: any = {};

        if (requestParameters.permission !== undefined) {
            queryParameters['permission'] = requestParameters.permission;
        }

        if (requestParameters.filterText !== undefined) {
            queryParameters['filterText'] = requestParameters.filterText;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/search`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Search direct and implied permissions of principals (users and groups). This endpoint returns a superset of the results returned by the /users and /groups endpoints because it allows filtering by global permissions too.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource.
     * Search project permissions
     */
    async searchPermissions(requestParameters: SearchPermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.searchPermissionsRaw(requestParameters, initOverrides);
    }

    /**
     * Creates or updates the auto decline settings for the supplied project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for this project to call the resource.
     * Create/Update auto decline settings
     */
    async setRaw(requestParameters: SetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAutoDeclineSettings>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling set.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/auto-decline`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restAutoDeclineSettingsRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates or updates the auto decline settings for the supplied project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for this project to call the resource.
     * Create/Update auto decline settings
     */
    async set(requestParameters: SetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAutoDeclineSettings> {
        const response = await this.setRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates/updates the hook script configuration for the provided hook script and project.   This endpoint requires **PROJECT_ADMIN** permission.
     * Create/update a hook script
     */
    async setConfigurationRaw(requestParameters: SetConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestHookScriptConfig>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling setConfiguration.');
        }

        if (requestParameters.scriptId === null || requestParameters.scriptId === undefined) {
            throw new runtime.RequiredError('scriptId','Required parameter requestParameters.scriptId was null or undefined when calling setConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/hook-scripts/{scriptId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"scriptId"}}`, encodeURIComponent(String(requestParameters.scriptId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restHookScriptTriggers,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates/updates the hook script configuration for the provided hook script and project.   This endpoint requires **PROJECT_ADMIN** permission.
     * Create/update a hook script
     */
    async setConfiguration(requestParameters: SetConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestHookScriptConfig> {
        const response = await this.setConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the default branch of a repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Update default branch for repository
     */
    async setDefaultBranch2Raw(requestParameters: SetDefaultBranch2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling setDefaultBranch2.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling setDefaultBranch2.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/default-branch`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restBranch,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update the default branch of a repository.   The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Update default branch for repository
     */
    async setDefaultBranch2(requestParameters: SetDefaultBranch2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setDefaultBranch2Raw(requestParameters, initOverrides);
    }

    /**
     * Promote or demote a group\'s permission level for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource. In addition, a user may not demote a group\'s permission level if theirown permission level would be reduced as a result.
     * Update group project permission
     */
    async setPermissionForGroups1Raw(requestParameters: SetPermissionForGroups1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling setPermissionForGroups1.');
        }

        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.permission !== undefined) {
            queryParameters['permission'] = requestParameters.permission;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/groups`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Promote or demote a group\'s permission level for the specified project.  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource. In addition, a user may not demote a group\'s permission level if theirown permission level would be reduced as a result.
     * Update group project permission
     */
    async setPermissionForGroups1(requestParameters: SetPermissionForGroups1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setPermissionForGroups1Raw(requestParameters, initOverrides);
    }

    /**
     * Promote or demote a user\'s permission level for the specified project.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource. In addition, a user may not reduce their own permission level unless they have a global permission that already implies that permission.
     * Update user project permission
     */
    async setPermissionForUsers1Raw(requestParameters: SetPermissionForUsers1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling setPermissionForUsers1.');
        }

        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.permission !== undefined) {
            queryParameters['permission'] = requestParameters.permission;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/permissions/users`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Promote or demote a user\'s permission level for the specified project.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project or a higher global permission to call this resource. In addition, a user may not reduce their own permission level unless they have a global permission that already implies that permission.
     * Update user project permission
     */
    async setPermissionForUsers1(requestParameters: SetPermissionForUsers1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setPermissionForUsers1Raw(requestParameters, initOverrides);
    }

    /**
     * Modify the settings for a repository hook for this project.   The service will reject any settings which are too large, the current limit is 32KB once serialized.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.   A JSON document can be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.
     * Update repository hook settings
     */
    async setSettingsRaw(requestParameters: SetSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExampleSettings>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling setSettings.');
        }

        if (requestParameters.hookKey === null || requestParameters.hookKey === undefined) {
            throw new runtime.RequiredError('hookKey','Required parameter requestParameters.hookKey was null or undefined when calling setSettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/hooks/{hookKey}/settings`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"hookKey"}}`, encodeURIComponent(String(requestParameters.hookKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.exampleSettings,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify the settings for a repository hook for this project.   The service will reject any settings which are too large, the current limit is 32KB once serialized.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.   A JSON document can be provided to use as the settings for the hook. These structure and validity of the document is decided by the plugin providing the hook.
     * Update repository hook settings
     */
    async setSettings(requestParameters: SetSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExampleSettings> {
        const response = await this.setSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the contributing guidelines for the repository, if they\'ve been defined.   This checks the repository for a CONTRIBUTING file, optionally with an md or txt extension, and, if found, streams it. By default, the <i>raw content</i> of the file is streamed. Appending <code>?markup</code> to the URL will stream an HTML-rendered version instead.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository contributing guidelines
     */
    async streamContributingRaw(requestParameters: StreamContributingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling streamContributing.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling streamContributing.');
        }

        const queryParameters: any = {};

        if (requestParameters.at !== undefined) {
            queryParameters['at'] = requestParameters.at;
        }

        if (requestParameters.markup !== undefined) {
            queryParameters['markup'] = requestParameters.markup;
        }

        if (requestParameters.htmlEscape !== undefined) {
            queryParameters['htmlEscape'] = requestParameters.htmlEscape;
        }

        if (requestParameters.includeHeadingId !== undefined) {
            queryParameters['includeHeadingId'] = requestParameters.includeHeadingId;
        }

        if (requestParameters.hardwrap !== undefined) {
            queryParameters['hardwrap'] = requestParameters.hardwrap;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/contributing`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves the contributing guidelines for the repository, if they\'ve been defined.   This checks the repository for a CONTRIBUTING file, optionally with an md or txt extension, and, if found, streams it. By default, the <i>raw content</i> of the file is streamed. Appending <code>?markup</code> to the URL will stream an HTML-rendered version instead.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository contributing guidelines
     */
    async streamContributing(requestParameters: StreamContributingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamContributingRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the license for the repository, if it\'s been defined.   This checks the repository for a <pre>LICENSE</pre> file, optionally with an <pre>md</pre> or <pre>txt</pre>extension, and, if found, streams it. By default, the <i>raw content</i> of the file is streamed. Appending <pre>?markup</pre> to the URL will stream an HTML-rendered version instead.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository license
     */
    async streamLicenseRaw(requestParameters: StreamLicenseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling streamLicense.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling streamLicense.');
        }

        const queryParameters: any = {};

        if (requestParameters.at !== undefined) {
            queryParameters['at'] = requestParameters.at;
        }

        if (requestParameters.markup !== undefined) {
            queryParameters['markup'] = requestParameters.markup;
        }

        if (requestParameters.htmlEscape !== undefined) {
            queryParameters['htmlEscape'] = requestParameters.htmlEscape;
        }

        if (requestParameters.includeHeadingId !== undefined) {
            queryParameters['includeHeadingId'] = requestParameters.includeHeadingId;
        }

        if (requestParameters.hardwrap !== undefined) {
            queryParameters['hardwrap'] = requestParameters.hardwrap;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/license`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves the license for the repository, if it\'s been defined.   This checks the repository for a <pre>LICENSE</pre> file, optionally with an <pre>md</pre> or <pre>txt</pre>extension, and, if found, streams it. By default, the <i>raw content</i> of the file is streamed. Appending <pre>?markup</pre> to the URL will stream an HTML-rendered version instead.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository license
     */
    async streamLicense(requestParameters: StreamLicenseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamLicenseRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the README for the repository, if it\'s been defined.   This checks the repository for a <pre>README</pre> file, optionally with an <pre>md</pre> or <pre>txt</pre>extension, and, if found, streams it. By default, the <i>raw content</i> of the file is streamed. Appending <pre>?markup</pre> to the URL will stream an HTML-rendered version instead. Note that, when streaming HTML, relative URLs in the README will not work if applied relative to this URL.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository readme
     */
    async streamReadmeRaw(requestParameters: StreamReadmeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling streamReadme.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling streamReadme.');
        }

        const queryParameters: any = {};

        if (requestParameters.at !== undefined) {
            queryParameters['at'] = requestParameters.at;
        }

        if (requestParameters.markup !== undefined) {
            queryParameters['markup'] = requestParameters.markup;
        }

        if (requestParameters.htmlEscape !== undefined) {
            queryParameters['htmlEscape'] = requestParameters.htmlEscape;
        }

        if (requestParameters.includeHeadingId !== undefined) {
            queryParameters['includeHeadingId'] = requestParameters.includeHeadingId;
        }

        if (requestParameters.hardwrap !== undefined) {
            queryParameters['hardwrap'] = requestParameters.hardwrap;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}/readme`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves the README for the repository, if it\'s been defined.   This checks the repository for a <pre>README</pre> file, optionally with an <pre>md</pre> or <pre>txt</pre>extension, and, if found, streams it. By default, the <i>raw content</i> of the file is streamed. Appending <pre>?markup</pre> to the URL will stream an HTML-rendered version instead. Note that, when streaming HTML, relative URLs in the README will not work if applied relative to this URL.   The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository to call this resource.
     * Get repository readme
     */
    async streamReadme(requestParameters: StreamReadmeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.streamReadmeRaw(requestParameters, initOverrides);
    }

    /**
     * Update the project matching the <strong>projectKey</strong> supplied in the resource path.   To include a custom avatar for the updated project, the project definition should contain an additional attribute with the key <code>avatar</code> and the value a data URI containing Base64-encoded image data. The URI should be in the following format:  ```    data:(content type, e.g. image/png);base64,(data)```  If the data is not Base64-encoded, or if a character set is defined in the URI, or the URI is otherwise invalid, <em>project creation will fail</em>.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Update project
     */
    async updateProjectRaw(requestParameters: UpdateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestProject>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling updateProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restProject,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the project matching the <strong>projectKey</strong> supplied in the resource path.   To include a custom avatar for the updated project, the project definition should contain an additional attribute with the key <code>avatar</code> and the value a data URI containing Base64-encoded image data. The URI should be in the following format:  ```    data:(content type, e.g. image/png);base64,(data)```  If the data is not Base64-encoded, or if a character set is defined in the URI, or the URI is otherwise invalid, <em>project creation will fail</em>.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Update project
     */
    async updateProject(requestParameters: UpdateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestProject> {
        const response = await this.updateProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the pull request merge strategy configuration for this project and SCM.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the context repository to call this resource.   Only the strategies provided will be enabled, the default must be set and included in the set of strategies.   An explicitly set pull request merge strategy configuration can be deleted by POSTing a document with an empty \"mergeConfig\" attribute. i.e:  <pre>{      \"mergeConfig\": {}  }  </pre>  Upon completion of this request, the effective configuration will be the configuration explicitly set for the SCM, or if no such explicit configuration is set then the default configuration will be used.
     * Update merge strategy
     */
    async updatePullRequestSettingsRaw(requestParameters: UpdatePullRequestSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPullRequestSettings>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling updatePullRequestSettings.');
        }

        if (requestParameters.scmId === null || requestParameters.scmId === undefined) {
            throw new runtime.RequiredError('scmId','Required parameter requestParameters.scmId was null or undefined when calling updatePullRequestSettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/settings/pull-requests/{scmId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"scmId"}}`, encodeURIComponent(String(requestParameters.scmId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restPullRequestSettings,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the pull request merge strategy configuration for this project and SCM.   The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the context repository to call this resource.   Only the strategies provided will be enabled, the default must be set and included in the set of strategies.   An explicitly set pull request merge strategy configuration can be deleted by POSTing a document with an empty \"mergeConfig\" attribute. i.e:  <pre>{      \"mergeConfig\": {}  }  </pre>  Upon completion of this request, the effective configuration will be the configuration explicitly set for the SCM, or if no such explicit configuration is set then the default configuration will be used.
     * Update merge strategy
     */
    async updatePullRequestSettings(requestParameters: UpdatePullRequestSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPullRequestSettings> {
        const response = await this.updatePullRequestSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the repository matching the <strong>repositorySlug</strong> supplied in the resource path.   The repository\'s slug is derived from its name. If the name changes the slug may also change.   This resource can be used to change the repository\'s default branch by specifying a new default branch in the request. For example: <code>\"defaultBranch\":\"main\"</code>  This resource can be used to move the repository to a different project by specifying a new project in the request. For example: <code>\"project\":{\"key\":\"NEW_KEY\"}</code>  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Update repository
     */
    async updateRepositoryRaw(requestParameters: UpdateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepository>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling updateRepository.');
        }

        if (requestParameters.repositorySlug === null || requestParameters.repositorySlug === undefined) {
            throw new runtime.RequiredError('repositorySlug','Required parameter requestParameters.repositorySlug was null or undefined when calling updateRepository.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters.repositorySlug))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restRepository,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the repository matching the <strong>repositorySlug</strong> supplied in the resource path.   The repository\'s slug is derived from its name. If the name changes the slug may also change.   This resource can be used to change the repository\'s default branch by specifying a new default branch in the request. For example: <code>\"defaultBranch\":\"main\"</code>  This resource can be used to move the repository to a different project by specifying a new project in the request. For example: <code>\"project\":{\"key\":\"NEW_KEY\"}</code>  The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified repository to call this resource.
     * Update repository
     */
    async updateRepository(requestParameters: UpdateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepository> {
        const response = await this.updateRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the avatar for the project matching the supplied <strong>projectKey</strong>.   This resource accepts POST multipart form data, containing a single image in a form-field named \'avatar\'.   There are configurable server limits on both the dimensions (1024x1024 pixels by default) and uploaded file size (1MB by default). Several different image formats are supported, but <strong>PNG</strong> and <strong>JPEG</strong> are preferred due to the file size limit.   This resource has Cross-Site Request Forgery (XSRF) protection. To allow the request to pass the XSRF check the caller needs to send an <code>X-Atlassian-Token</code> HTTP header with the value <code>no-check</code>.   An example <a href=\"http://curl.haxx.se/\">curl</a> request to upload an image name \'avatar.png\' would be: ```curl -X POST -u username:password -H \"X-Atlassian-Token: no-check\" http://example.com/rest/api/1.0/projects/STASH/avatar.png -F avatar=@avatar.png ```  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Update project avatar
     */
    async uploadAvatarRaw(requestParameters: UploadAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling uploadAvatar.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.avatar !== undefined) {
            formParams.append('avatar', requestParameters.avatar as any);
        }

        const response = await this.request({
            path: `/api/latest/projects/{projectKey}/avatar.png`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update the avatar for the project matching the supplied <strong>projectKey</strong>.   This resource accepts POST multipart form data, containing a single image in a form-field named \'avatar\'.   There are configurable server limits on both the dimensions (1024x1024 pixels by default) and uploaded file size (1MB by default). Several different image formats are supported, but <strong>PNG</strong> and <strong>JPEG</strong> are preferred due to the file size limit.   This resource has Cross-Site Request Forgery (XSRF) protection. To allow the request to pass the XSRF check the caller needs to send an <code>X-Atlassian-Token</code> HTTP header with the value <code>no-check</code>.   An example <a href=\"http://curl.haxx.se/\">curl</a> request to upload an image name \'avatar.png\' would be: ```curl -X POST -u username:password -H \"X-Atlassian-Token: no-check\" http://example.com/rest/api/1.0/projects/STASH/avatar.png -F avatar=@avatar.png ```  The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified project to call this resource.
     * Update project avatar
     */
    async uploadAvatar(requestParameters: UploadAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.uploadAvatarRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const GetRepositoryHooksTypeEnum = {
    PreReceive: 'PRE_RECEIVE',
    PostReceive: 'POST_RECEIVE'
} as const;
export type GetRepositoryHooksTypeEnum = typeof GetRepositoryHooksTypeEnum[keyof typeof GetRepositoryHooksTypeEnum];
/**
 * @export
 */
export const GetRestrictionsMatcherTypeEnum = {
    Branch: 'BRANCH',
    Pattern: 'PATTERN',
    ModelCategory: 'MODEL_CATEGORY',
    ModelBranch: 'MODEL_BRANCH'
} as const;
export type GetRestrictionsMatcherTypeEnum = typeof GetRestrictionsMatcherTypeEnum[keyof typeof GetRestrictionsMatcherTypeEnum];
/**
 * @export
 */
export const GetRestrictionsTypeEnum = {
    ReadOnly: 'read-only',
    NoDeletes: 'no-deletes',
    FastForwardOnly: 'fast-forward-only',
    PullRequestOnly: 'pull-request-only'
} as const;
export type GetRestrictionsTypeEnum = typeof GetRestrictionsTypeEnum[keyof typeof GetRestrictionsTypeEnum];
